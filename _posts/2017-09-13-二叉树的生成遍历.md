
## python中的树

树是一种很重要的数据结构，今天搞明白了，好好记录一下，借用了大神的博客的信息，感谢这些好人
（原文链接：http://blog.csdn.net/bone_ace/article/details/46718683）
当然也是对相应的非递归的方法进行了相应的简化，更容易理解和记忆了


[二叉树生成动图链接](https://github.com/yuzp1996/yuzp1996.github.io/blob/master/websites/treeaddGig.gif)

```
#coding=utf-8

class Node(object):
    """节点类"""
    def __init__(self, elem=-1, lchild=None, rchild=None):
        self.elem = elem
        self.lchild = lchild
        self.rchild = rchild


class Tree(object):
    """树类"""
    def __init__(self):
        self.root = Node()
        self.myQueue = []

    def add(self, elem):
        """为树添加节点"""
        node = Node(elem)
        if self.root.elem == -1:  # 如果树是空的，则对根节点赋值
            self.root = node
            self.myQueue.append(self.root)
        else:
            treeNode = self.myQueue[0]  # 此结点的子树还没有齐。
            if treeNode.lchild == None:
                treeNode.lchild = node
                self.myQueue.append(treeNode.lchild)
            else:
                treeNode.rchild = node
                self.myQueue.append(treeNode.rchild)
                self.myQueue.pop(0)  # 如果该结点存在右子树，将此结点丢弃。


    def front_digui(self, root):
        """利用递归实现树的先序遍历"""
        if root == None:
            return
        print root.elem,
        self.front_digui(root.lchild)
        self.front_digui(root.rchild)


    def middle_digui(self, root):
        """利用递归实现树的中序遍历"""
        if root == None:
            return
        self.middle_digui(root.lchild)
        print root.elem,
        self.middle_digui(root.rchild)


    def later_digui(self, root):
        """利用递归实现树的后序遍历"""
        if root == None:
            return
        self.later_digui(root.lchild)
        self.later_digui(root.rchild)
        print root.elem,


    def front_stack(self, root):
        """利用堆栈实现树的先序遍历"""
        stack = []
        stack.append(root)    #把根节点塞进去之后，就是弹，输出，然后赛左右节点
        while len(stack):
            node = stack.pop()
            print node.elem,
            if node.rchild:
                stack.append(node.rchild)
            if node.lchild:
                stack.append(node.lchild)


    def middle_stack(self, root):
        """利用堆栈实现树的中序遍历"""
        stack = []
        node = root
        while  node or len(stack): #也是一个劲的赛左子树，直到到了左头，往外弹，输出并且切换到右子树上
            if node:
                stack.append(node)
                node = node.lchild
            else:
                node = stack.pop()
                print node.elem,
                node = node.rchild


    def later_stack(self, root):
        """利用堆栈实现树的后序遍历"""
        s1 = []
        s2 = []
        s1.append(root)
        while len(s1):    #先把脑袋塞进去，弹出来给s2，然后把左右节点放进去，然后往外弹给s2，给完了之后再弹出s2即可
            node = s1.pop()
            s2.append(node)
            if node.lchild:
                s1.append(node.lchild)
            if node.rchild:
                s1.append(node.rchild)
        while len(s2):
            print s2.pop().elem,


    def level_queue(self, root):
        """利用队列实现树的层次遍历"""
        if root == None:
            return
        myQueue = []  # 把头放进去，然后左右不空就放到queue中，每次都弹出第一个而且输出
        node = root
        myQueue.append(node)
        while myQueue:
            node = myQueue.pop(0)
            print node.elem,
            if node.lchild != None:
                myQueue.append(node.lchild)
            if node.rchild != None:
                myQueue.append(node.rchild)
 if __name__ == '__main__':
    """主函数"""
    elems = range(10)           #生成十个数据作为树节点
    tree = Tree()          #新建一个树对象
    for elem in elems:                  
        tree.add(elem)           #逐个添加树的节点

    print tree.root.elem
    print u'队列实现层次遍历:'
    tree.level_queue(tree.root)

    print u'\n\n递归实现先序遍历:'
    tree.front_digui(tree.root)
    print u'\n递归实现中序遍历:' 
    tree.middle_digui(tree.root)
    print u'\n递归实现后序遍历:'
    tree.later_digui(tree.root)

    print u'\n\n堆栈实现先序遍历:'
    tree.front_stack(tree.root)
    print u'\n堆栈实现中序遍历:'
    tree.middle_stack(tree.root)
    print u'\n堆栈实现后序遍历:'
    tree.later_stack(tree.root)
```
下面是相应的关于二叉树的问题，再次记录下来

```
# 判断子树   都是递归
class Solution:
    def HasSubtree(self, pRoot1, pRoot2): #先通过比较当前两个树的根节点是否有包含关系，在比较左右子树。
        # write code here
        if not pRoot1 or not pRoot2:  #有一个为空就是输出错误
            return False
        return self.is_subtree(pRoot1, pRoot2) or   #看两个树是否包含，看左子树是否包含，右子树是否包含
               self.HasSubtree(pRoot1.left, pRoot2) or 
               self.HasSubtree(pRoot1.right, pRoot2)
     
    def is_subtree(self, A, B): #主要是看左子节点跟右子节点
        if not B:    # B为空，比到头了，可以了，正确，只有比到B的尾部才可以。
            return True
        if not A or A.val != B.val:  # A没有或者A与B的值不等
            return False
        return self.is_subtree(A.left,B.left) and 
               self.is_subtree(A.right, B.right)


# 1，HasSubtree  都当做根节点来比较，然后把左子节点与右边的比，左子节点与右边的比，有一个成功就行。
# 2，is_subtree 根节点的比较，就直接假设成要比较的开始节点
```


重建二叉树，给你前序遍历和中序遍历

```
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if len(pre) == 0:
            return None
        elif len(pre) == 1:
            return TreeNode(pre[0])
        else:
            ans = TreeNode(pre[0])
            ans.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1],tin[:tin.index(pre[0])]) 
            ans.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:],tin[tin.index(pre[0])+1:])
            return ans
```


这个问题用递归用的很巧妙，其实就和用字典的感觉一样，每次加了值之后，需要求和的值就会发生变化，减少相应的数量，所以，比到最后，只要子节点不等于最后应该等于的值，那他就是错的,就不是那个路径

```
输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        #终止条件
        if not root:
            return []
        #结果条件
        if root and not root.left and not root.right and root.val == expectNumber:
            return [[root.val]]  #这个返回列表

        #核心代码
        res = []
        left = self.FindPath(root.left, expectNumber-root.val)
        right = self.FindPath(root.right, expectNumber-root.val)
       
       #结果合并
        for i in left+right:
            res.append([root.val]+i)
        return res

    def FindPath(self, root, expectNumber):
        # write code here
        if not root:
            return []
        if root and not root.left and not root.right and root.val == expectNumber:
            return [[root.val]]
        
        res = []
        left = self.FindPath(root.left, expectNumber-root.val)
        right = self.FindPath(root.right,expectNumber-root.val)
        
        for i in left+right:
            res.append([root.val]+i)
        return res




```

***
牛客网 数组问题

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)

*
算法时间复杂度O（n）
用total记录累计值，maxSum记录和最大
基于思想：对于一个数A，若是A的左边累计数非负，那么加上A能使得值不小于A，认为累计值对
整体和是有贡献的。如果前几项累计值负数，则认为有害于总和，total记录当前值。
此时 若和大于maxSum 则用maxSum记录下来
*/

```
# -*- coding:utf-8 -*-
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        # write code here
        if len(array) < 2:
            return array
        maxNum = array[0]
        total = array[0]
        for i in array[1:]:
            if total > 0:
                total += i
            else:
                total = i
            if total > maxNum:
                maxNum = total
        return maxNum

```
***
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

### 第一步
|1|, 2,4,7,3,5,6,8

4,7,2, |1|, 5,3,8,6

1是根，4,7,2是左子树，5,3,8,6是右子树，再把左右子树拿出来

### 第二步

|2|,4,7

4,7,|2|

2是根，4,7是左子树。


其实5,3,8,6也是一个德行，然后就是该死的递归。

(w我觉得递归吧，看别人写，再理解，感觉递归真棒，然后自己就鞋不错来，现在自己总结了，分成这个几步

1. 先在程序里写出递归的语句

```
 ans.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1],tin[:tin.index(pre[0])])
 
 ans.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:],tin[tin.index(pre[0])+1:])
```

)

2.想想应该输出什么，写出来，

```
        elif len(pre) == 1:
            return TreeNode(pre[0])

        return ans
```

3.其实就是按最初始的 简单的那个第一极的循环来做，然后涉及到其他的循环，比如闭合条件什么的，在后面考虑




```
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if len(pre) == 0:    #输出结果
            return None  
        elif len(pre) == 1:    #成立条件
            return TreeNode(pre[0])
        else:
            ans = TreeNode(pre[0])   #开始循环   应该先建立根节点，然后是左右子树   
            ans.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1],tin[:tin.index(pre[0])]) #返回的是已经有了左右子节点的树节点
            ans.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:],tin[tin.index(pre[0])+1:])
            return ans
```

***

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None    
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        if not pRoot1 or not pRoot2: #只要有一个为空，就说明不是子树，不管是大树还是小树
            return False
        return self.is_subtree(pRoot1,pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) or self.HasSubtree(pRoot1.left,pRoot2)
    def is_subtree(self,A,B):
        if not B:  #把B给比对完了，就说明B一直在这个大树内，没有跑出来大树的范围
            return True
        if not A or A.val != B.val:
            return False
        return self.is_subtree(A.right,B.right) and self.is_subtree(A.left,B.left)
```


***

我感觉这个题目还人性化点

操作给定的二叉树，将其变换为源二叉树的镜像

```
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if root != None:
            root.right, root.left = root.left, root.right
            self.Mirror(root.right)
            self.Mirror(root.left)

```


****

这个递归算是自己写出来的吧

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。


```

# -*- coding:utf-8 -*-
class Solution:
    def VerifySquenceOfBST(self,sequence):
        # write code here
 
        if not sequence:  #这是结果
            return False
        if len(sequence)==1: #比到最后还有一个，就说明之前的比较全部通过，
            return True


        root = sequence[-1]    #确定比较条件 如果有错就返回False
        index = 0
        for i in sequence:
            if i<root:
                index += 1
            else:
                break
        smallList = [i for i in sequence[:index] if i>root]
        bigList = [i for i in sequence[index:-1] if i<root]
        if len(smallList)>0 or len(bigList)>0:
            return False


        leftIs = True        # 开始递归
        rightIs = True
        if len(sequence[:index])>0:
            leftIs = self.VerifySquenceOfBST(sequence[:index])
        if len(sequence[index:-1])>0:
            rightIs = self.VerifySquenceOfBST(sequence[index:-1])
        
        return leftIs and rightIs

```

#真的 二叉树看的我快吐了

***

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径

```
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        if not root: #终止条件
            return []
        if root and not root.left and not root.right and root.val == expectNumber: #结果条件
            return [[root.val]]
        
        res = []
        left = self.FindPath(root.left, expectNumber-root.val)  #递归
        right = self.FindPath(root.right,expectNumber-root.val)  #递归
        
        for i in left+right:  #这个就按初始的条件来，不是有左右子树呢，要把左右子树都拿进来呀，so
            res.append([root.val]+i)
        return res


#为了简便理解 ，可以先在深度为2的树上来研究代码怎么写，然后修正，推广到更深的树上去

```