### Python排序算法集合

##### 一切只为更简单

先说我最喜欢的排序，快速排序

```
# -*- coding: utf-8 -*-

import random
testList = [44,5,6,4,23,23]

# 快速排序
def quick_sort(L):
    if len(L)<2:return L     #这个应该是早点进行判断的
    CountNum = random.choice(L)
    smallList = [i for i in L if i < CountNum]
    #middle = [i for i in L if i == CountNum]
    largeList = [i for i in L if i > CountNum]
    finallList = FirstSort(smallList) + [CountNum] + FirstSort(largeList)#    这里进行了去重操作
    return finallList  # 直接返回对象  让后来调用的时候进行输出  也就是print 这里应该只返回对象 不能输出  其他的调用的时候还要调用呢

print FirstSort(testList)

```


比较简单的堆排序
```

# -*- coding: utf-8 -*-
#冒泡排序  从左往右走，每次都把最小的挑出来

testList = [1,232,4,3,22,434,56,43,655,32,54,3]

# def bubble_sort(L):
#     count = len(L)
#     for i in range(0,count):
#         for j in range(i, count):
#             if L[i]>L[j]:L[i],L[j] = L[j],L[i]
#     return L

# print bubble_sort(testList)





def bubble_sort(List):
    count = len(List)
    for i in range(count):
        for j in range(i+1, count):
            if List[i] > List[j]:
                List[i], List[j] = List[j], List[i]
    return List


print bubble_sort(testList)
```




然后是插入排序

```
# -*- coding: utf-8 -*-

testList = [3233,1,2,43,22,432,44,543,5,44,34,33,33,432]


# 插入排序 一个数据插入到已经排好序的有序数据中 从左往右 把每次遇到的数都跟之前排过的进行比较
# def insert_sort(L):
#     L = list(set(L))
#     count = len(L)
#     if count == 1: return L
#     for j in range(1,count): #切记从1开始，因为有一个0元素
#         for i in range(j, 0, -1):
#             if L[i]<L[i-1]:
#                 L[i], L[i-1] = L[i-1], L[i]
#         print L
#     return L
# print insert_sort(testList)


def insert_sort(List):
    count = len(List)
    for i in range(count):
        for j in range(i, 0, -1): #从i开始就好啦，前面的for循环的i到不了i的,这里之所以不用到了 -1 不用写成(i,-1,-1)是因为下面是用j-1实现的，到了0，0再减一
            if List[j-1] > List[j]:
                List[j-1], List[j] = List[j], List[j-1]
    return List

print insert_sort(testList)

```

选择排序

```

def select_sort(List):
    count = len(List)
    for i in range(count):
        min = i
        for j in range(i+1,count):
            if List[j] < List[min]: #应该是和比较出来的、最小的进行比较
                min = j
        List[i],List[min] =  List[min], List[i]

    return List
print(select_sort(testList))
```



希尔排序

```
import random

def shell_sort(List):
    count = len(List)
    gap = count//2
    while gap>0:
        for i in range(gap, count):
            tmp = List[i]
            while i-gap >= 0 and List[i-gap] > tmp: # 这才是真正的插入排序 这是自己写出来的算法 很好 只不过是应该是i-gap>=0 不是大于0 因为要和第一个元素进行比较呀 你不能剥夺了和第一个比较的权力呀
                List[i], List[i-gap] = List[i-gap], List[i]  #你小就把你换到前面去，再拿你跟前面的比 如果还小 还望前面拿
                i -= gap #最开始其实只有两个元素进行比较，后来慢慢往右走慢慢的增加元素，（但是还是和左边的比较）每次增加一个，前面的元素已经有了次序从小到大的次序
        gap = gap//2
    return List

testList = [random.randint(0,233) for i in range(1,334)]
print testList

start = time.clock()
print (shell_sort(testList))
elapsed = (time.clock()-start)
print elapsed
```
合并排序

```
testList = [2,34,5,22,4,323,343243243243,4,2323,4,3,45,432,55]

def merge(left, right):
    i = 0
    j = 0
    result = []
    leftlen = len(left)
    rightlen = len(right)
    while i < leftlen and j < rightlen:
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result

def merge_sort(List):

    if len(List) == 1:
        return List  # 这也是为了排序做准备的 是做准备 他不排序 他只负责分出left与right
    num = len(List)//2
    left = merge_sort(List[:num]) # 这也是为了排序做准备的 是做准备 他不排序 他只负责分出left与right
    right = merge_sort(List[num:]) # 这也是为了排序做准备的 是做准备 他不排序 他只负责分出left与right
    return merge(left, right) # 这里才是真正的排序 最后才排序


print merge_sort(testList)
```

桶排序

```
import random
import math

def redix_sort():
    A = [random.randint(1,99) for i in range(1,99)]
    circle = int(math.ceil(math.log(max(A), 10)))
    for i in range(circle): #位数
        S = [[] for k in range(0,10)]  #变量不能瞎用，最好不要重名，要会用变量 每次都建一个数组
        for a in A: 
           S[a/(10**i)%10].append(a)
        A = [a for b in S for a in b ]  #在这储存排序成果以便下次使用
    return A

print redix_sort()
```

堆排序

```
def Max_heapify(heap, MaxSize, root):
    left = root*2+1
    right = left+1
    larger = root
    if left < MaxSize and heap[left] > heap[larger]:  #不是<= 如果是等于的话 那就超标了吧 len与列表下标总是差一个
        larger = left
    if right < MaxSize and heap[right] > heap[larger]: #不是<= 如果是等于的话 那就超标了吧 len与列表下标总是差一个
        larger = right
    if root != larger:
        heap[root], heap[larger] = heap[larger], heap[root]
        Max_heapify(heap, MaxSize,larger) #如果大的在左边或者右边，就有可能他们的子节点的值也很大，所以要对这个节点进行堆排

def merge(heap):
    count = len(heap)
    num = (count-2)//2
    for i in range(num, -1, -1):
        Max_heapify(heap, count, i)  # root是个位置标量

    for i in range(count-1,0,-1):  # 是count-1，如果是count那就超了
        heap[0], heap[i] = heap[i], heap[0]
        count -= 1
        Max_heapify(heap, i, 0)

    return heap

print merge(a)

```
