###  做了这么长时间的题了，总觉得边做边忘，没有好的办法，只有再做一遍，好好总结。放在博客上以供随时瞻仰

## 字符串问题

1 知识点

  [正则表达式](http://www.runoob.com/python/python-reg-expressions.html)

   * compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。

 
 
2 字符匹配替换问题
   

* 将一个字符串s中的空格替换成“q”

 ```
import re

 b = re.sub(' ','q',s)
 b = re.compile(' ').sub('q',s)

 ```


***
### 反转数字
class Solution(object):
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        r = -cmp(0, x)
        p = int(`r*x`[::-1])
        return p*r*(p<2**32)


***

### 一般来说 来找数目多少的话 用字典是一个不错的选择
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

```
# -*- coding:utf-8 -*-
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        # write code here
        Dict = {}
        for i in array:
            try:
                Dict[i] += 1
            except:
                Dict[i] = 1
        List = [i for i in Dict if Dict[i] == 1]
        return List[0],List[1]
```

****

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数
序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!


第一种解法，有数学公式在里面  

> (an+a1)*(an-a1+1)=2*s

```
# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        Result = [];
        for i in range(1,tsum/2+1):
            for j in range(i, tsum/2+2):
                SUM = (i+j)*(j-i+1)/2
                if SUM>tsum:
                    break
                elif SUM == tsum:
                    Result.append(range(i,j+1))
        return Result

//左神的思路，双指针问题
//当总和小于sum，大指针继续+
//否则小指针+

# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        res = []
        allLen = tsum
        i = 1
        j = 1
        addsum = 1
        while j < allLen:
            if addsum<tsum:
                j += 1
                addsum += j
            elif addsum>tsum:
                addsum -= i
                i += 1
            else:
                res.append(range(i,j+1))    #问题在这里出现了，相等的话应该让小指针右移，不只是i += 1，应该相应的将addsum减少
                addsum -= i
                i += 1
        return res


***

输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

# -*- coding:utf-8 -*-
class Solution:
    def FindNumbersWithSum(self,array, tsum):
        # write code here
        ls = []
        for i,v in enumerate(array):
            for j in array[i:]:
                if v+j == tsum:
                    ls.append([v,j])
                    break
        if ls:
            return ls[0]
        return ls 


当然这也是一个指针的问题，所以斗胆用前后指针实现一哈


# -*- coding:utf-8 -*-
class Solution:
    def FindNumbersWithSum(self,array, tsum):
        # write code here
        lenofarray = len(array)
        i = 0
        j = lenofarray-1
        while i<lenofarray and j>0 and i<j:
            if array[i]+array[j]>tsum:
                j -= 1
            elif array[i]+array[j]<tsum:
                i += 1
            else:
                return array[i],array[j]
        return []



***
顺时针打印某个数组

class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        # write code here
        res = []
        while matrix:
            res.extend(matrix.pop(0))    //打印第一行
            if not matrix or not matrix[0]:
                break
            matrix = self.turn(matrix)    //转换
        return res
    
    def turn(self,List):
        newList = []
        lenofy = len(List)
        lenofx = len(List[0])
        for i in range(lenofx):
            tmplist=[]    //要在这里进行弄空，并且进行tmplist的赋值
            for j in range(lenofy):
                tmplist.append(List[j][i])
            newList.append(tmplist)
        newList.reverse()
        return newList




****

判断是否出栈顺序与入栈顺序   

class Solution:
    def IsPopOrder(self, pushV, popV):
        # write code here
        stack = []
        for i in pushV:
            stack.append(i)
            while len(stack) and stack[-1] == popV[0]:  #总要有个终止条件，也就是长度为0的时候
                stack.pop(-1)
                popV.pop(0)
        if len(stack) == 0:
            return True
        return False



****
给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。


这是一个(O)2的解法，感觉比较慢，下面用一个(O)的解法

# -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        # write code here
        res = []
        for i in range(len(A)):
            perNum = 1
            nextNum = 1
            for j in A[0:i]:
                perNum *= j
            for q in A[i+1:]:
                nextNum *= q
            res.append(nextNum*perNum)
        return res

这是一个(o)1的解法
# -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        # write code here
        if not A:
            return []

        # 计算前面一部分
        num = len(A)
        B = [None] * num
        B[0] = 1
        for i in range(1, num):
            B[i] = B[i-1] * A[i-1]


        # 计算后面一部分
        # 自下而上
        # 保留上次的计算结果乘本轮新的数,因为只是后半部分进行累加，所以设置一个tmp,能够保留上次结果
        tmp = 1
        for i in range(num-2, -1, -1):
            tmp *= A[i+1]   
            B[i] *= tmp
        return B


# -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        # write code here
        LenofA = len(A)
        Per = [None]*LenofA
        Per[0] = 1
        
        # 主体函数 此时per[0]已经赋值，需要的是求接下来的各个的Per中的值
        for i in range(1,LenofA):
            Per[i] = Per[i-1]*A[i-1]

        #上面那个是正着来求，咱们是从尾部到头部反着来求。这里不用存储 直接与正着求得Per进行相乘就可以  实例：[(1 2 3 4) # (6 7 8 9)],
        #正着求1 2 3 4的乘积，再去倒着求9 8 7 6与前面对应的乘积
        tmp = 1
        for j in range(LenofA-2,-1,-1):
            tmp *= A[j+1]
            Per[j] *= tmp

        return Per







# -*- coding:utf-8 -*-
class Solution:
    def hasPath(self, matrix, rows, cols, path):
        # write code here
        for i in range(rows):
            for j in range(cols):
                if matrix[i*cols+j]==path[0]:
                    if return self.findPath(list(matrix),rows,i,cols,j,path[1:]): # 这里传过去的值是一个列表 因为字符串是不可以修改的呦，为了防止
                        return True                                                               #度过去的数再被读，要对他进行修改 而且不能直接返回self.findPath(list(matrix),rows,i,cols,j,path[1:])，因为有很多情况是不对的，只有True的时候才能返回True
        return False
    

    def findPath(self,matrix,rows,row,cols,col,path):
        matrix[row*cols+col]='0'    #读过去的数不要再读了

        if len(path) == 0:
            return True
        if col+1<cols and matrix[cols*row+col+1]==path[0]:
            return self.findPath(matrix,rows,row,cols,col+1,path[1:])
        elif col-1>=0 and matrix[cols*row+col-1]==path[0]:
            return self.findPath(matrix,rows,row,cols,col-1,path[1:])
        elif row+1<rows and matrix[cols*(row+1)+col]==path[0]:
            return self.findPath(matrix,rows,row+1,cols,col,path[1:])
        elif row-1>=0 and matrix[cols*(row-1)+col]==path[0]:
            return self.findPath(matrix,rows,row-1,cols,col,path[1:])
        else:
            return False









```


```
RE模块的使用

问题一 丧心病狂的fish与弱智神经的cat(反转一句话，I am a student. ===> student. a am I)

# -*- coding:utf-8 -*-
import re
class Solution:
    def ReverseSentence(self, s):
        # write code here
        if len(s.strip()) == 0:    # 这里主要是针对的 ""与" "这种情况
            return s 
        L = s.split()
        L.reverse()
        return ' '.join(L)


str转int  虽然用try except也能做，但是这个做法还是更友善一些。
# -*- coding:utf-8 -*-
import re
class Solution:
    def StrToInt(self, s):
        # write code here
        if not re.match(r'^[\+\-]?[0-9]+$', s):
            return 0
        return int(s)






```

