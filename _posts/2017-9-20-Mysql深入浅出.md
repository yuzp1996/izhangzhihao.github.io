****
#### SQL分类

SQL 语句主要可以划分为以下 3 个类别。




|特性  |DDL |DML |DCL|
|---| --- | ---|---|
|定义|数据定义语言|数据操纵语句|数据控制语句|
|作用|定义了不同的数据段、数据库、表、列、索引等数据库对象的定义|用于添加、删除、更新和查询数据库记录，并检查数据完整性|数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别|
|关键字|create、drop、alter等。| insert、delete、udpate 和select 等。|grant、revoke|
|特性|DDL 语句更多的被数据库管理员（DBA）所使用|DML 只是对表内部数据的操作||

*****
### 关键语法

>CREATE DATABASE dbname;

[可能出现的问题](http://blog.sina.com.cn/s/blog_7d553bb50102w9rb.html)

>show databases;

安装MySQL 时系统自动创建的，其各自功能如下。

|表名|information_schema|cluster|mysql|test|
|----|----|----|----|----|
|功能|主要存储了系统中的一些数据库对象信息。比如用户表信息、列信息、权限信息、字符集信息、分区信息等。|存储了系统的集群信息|存储了系统的用户权限信息。|系统自动创建的测试数据库，任何用户都可以使用|


> USE dbname;

> show tables;

删库
>drop database dbname;

在数据库中创建一张表的基本语法如下：

```
CREATE TABLE tablename (column_name_1 column_type_1 constraints，column_name_2  column_type_2  constraints ， ……column_name_n  column_type_n
constraints）

实例	>create table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2));

```

表创建完毕后，如果需要查看一下表的定义，可以使用如下命令：

>DESC tablename

```
mysql> desc emp;
+----------+---------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+----------+---------------+------+-----+---------+-------+
| ename | varchar(10) | YES | | | |
| hiredate | date | YES | | | |
| sal | decimal(10,2) | YES | | | |
| deptno | int(2) | YES | | | |
+----------+---------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

详细：更详细，比如存储引擎，字符集

>show create table emp \G;

```
mysql> show create table emp \G;
*************************** 1. row ***************************
Table: emp
Create Table: CREATE TABLE `emp` (
`ename` varchar(20) DEFAULT NULL,
`hiredate` date DEFAULT NULL,
`sal` decimal(10,2) DEFAULT NULL,
`deptno` int(2) DEFAULT NULL,
```


删除表

>DROP TABLE tablename


*****

#### 在大多数情况下，表结构的更改一般都使用 alter table 语句，以下是一些常用的命令。

（1） 修改表类型，语法如下：

>ALTER TABLE tablename MODIFY [COLUMN] column_definition [FIRST | AFTER col_name]

修改表 emp 的 ename 字段定义，将 varchar(10)改为 varchar(20)

```alter table emp modify ename varchar(20);```

（2）增加表字段，语法如下：

>ALTER TABLE tablename ADD [COLUMN] column_definition [FIRST | AFTER col_name]

例如，表 emp 上新增加字段 age，类型为 int(3)

```alter table emp add column age int(3);```

（3）删除表字段，语法如下：

>ALTER TABLE tablename DROP [COLUMN] col_name

例如，将字段 age 删除掉：

mysql> alter table emp drop column age;


注意：change 和 modify都可以修改表的定义，不同的是 change 后面需要写两次列名，不方便。
但是 change 的优点是可以修改列名称，modify则不能。


（5）修改字段排列顺序。

前面介绍的的字段增加和修改语法（ADD/CNAHGE/MODIFY）中，都有一个可选项 first|after
column_name，这个选项可以用来修改字段在表中的位置，默认 ADD 增加的新字段是加在
表的最后位置，而 CHANGE/MODIFY 默认都不会改变字段的位置。

例如，将新增的字段 birth date 加在 ename 之后：

>alter table emp add birth date after ename;

修改字段 age，将它放在最前面：

>mysql> alter table emp modify age int(3) first;

（6）表改名，语法如下：

>ALTER TABLE tablename RENAME [TO] new_tablename

例如，将表 emp 改名为 emp1，命令如下：

>mysql> alter table emp rename emp1;

*****

## DML 操作是指对数据库中表记录的操作， 主要包括表记录的插入 （insert） 、 更新 （update） 、删除（delete）和查询（select） ，是开发人员日常使用最频繁的操作。


### 1插入记录

>INSERT INTO tablename (field1,field2,……fieldn) VALUES(value1,value2,……valuesn);

实例：
>> insert into emp (ename,hiredate,sal,deptno) values('zzx1','2000-01-01','2000',1);

查看
>select * from emp

### 更新记录

>UPDATE tablename SET field1=value1，field2.=value2，……fieldn=valuen [WHERE CONDITION]

实例
> update emp set sal=4000 where ename='lisa';


update 命令可以同时更新多个表中数据，语法如下：

>UPDATE t1,t2…tn set t1.field1=expr1,tn.fieldn=exprn [WHERE CONDITION]

实例

>update  emp  a,dept b  set  a.sal=a.sal*b.deptno,b.deptname=a.ename  where
a.deptno=b.deptno;

多表更新的语法更多地用在了根据一个表的字段，来动态的更新另外一个表的字段



#### 删除记录

>DELETE FROM tablename [WHERE CONDITION]

例如，在 emp 中将 ename 为‘dony’的记录全部删除，命令如下：

> delete from emp where ename='dony';


在 MySQL 中可以一次删除多个表的数据，语法如下：
DELETE t1,t2…tn FROM t1,t2…tn [WHERE CONDITION]

> delete a,b from emp a,dept b where a.deptno=b.deptno and a.deptno=3;

不管是单表还是多表， 不加 where 条件将会把表的所有记录删除， 所以操作时一定要小心。


#### 查询记录

>SELECT * FROM tablename [WHERE CONDITION]


```
1）查询不重复的记录。
有时需要将表中的记录去掉重复后显示出来，可以用 distinct 关键字来实现：
mysql> select ename,hiredate,sal,deptno from emp;
+--------+------------+---------+--------+
| ename | hiredate | sal | deptno |
+--------+------------+---------+--------+
| zzx | 2000-01-01 | 2000.00 | 1 |
| lisa | 2003-02-01 | 4000.00 | 2 |
| bjguan | 2004-04-02 | 5000.00 | 1 |
+--------+------------+---------+--------+
3 rows in set (0.00 sec)
mysql> select distinct deptno from emp;
+--------+
| deptno |
+--------+
| 1 |
| 2 |
+--------+
2 rows in set (0.00 sec)
```

> select * from emp where deptno=1;

（3）排序和限制。
我们经常会有这样的需求， 取出按照某个字段进行排序后的记录结果集， 这就用到了数据库
的排序操作，用关键字 ORDER BY 来实现，语法如下：

>SELECT * FROM tablename [WHERE CONDITION] [ORDER BY field1 [DESC|ASC]，field2
[DESC|ASC]，……fieldn [DESC|ASC]]

其中，DESC 和 ASC 是排序顺序关键字，DESC 表示按照字段进行降序排列，ASC 则表示升序
排列，如果不写此关键字默认是升序排列。ORDER BY 后面可以跟多个不同的排序字段，并
且每个排序字段可以有不同的排序顺序。


对于排序后的记录，如果希望只显示一部分，而不是全部，这时，就可以使用 LIMIT 关键字
来实现，LIMIT 的语法如下：

>SELECT ……[LIMIT offset_start,row_count]

其中 offset_start 表示记录的起始偏移量，row_count 表示显示的行数。

emp 表中按照 sal 排序后的前 3 条记录：

mysql> select * from emp order by sal limit 3;

如果要显示 emp 表中按照 sal 排序后从第二条记录开始，显示 3 条记录：

mysql> select * from emp order by sal limit 1,3;



（4）聚合。
很多情况下，我们需要进行一些汇总操作，比如统计整个公司的人数或者统计每个部门的人
数，这个时就要用到 SQL 的聚合操作。


聚合操作的语法如下：

```
SELECT [field1,field2,……fieldn] fun_name
FROM tablename
[WHERE where_contition]
[GROUP BY field1,field2,……fieldn
[WITH ROLLUP]]
[HAVING where_contition]

```
对其参数进行以下说明。

1 fun_name 表示要做的聚合操作，也就是聚合函数，常用的有 sum（求和）、count(*)（记
录数）、max（最大值）、min（最小值）。

2 GROUP BY 关键字表示要进行分类聚合的字段，比如要按照部门分类统计员工数量，部门
就应该写在 group by 后面。

3 WITH ROLLUP 是可选语法，表明是否对分类聚合后的结果进行再汇总。

4 HAVING 关键字表示对分类后的结果再进行条件的过滤


```
注意：having 和 where 的区别在于 having 是对聚合后的结果进行条件的过滤，而 where 是在聚
合前就对记录进行过滤，如果逻辑允许，我们尽可能用 where 先过滤记录，这样因为结果
集减小，将对聚合的效率大大提高，最后再根据逻辑看是否用 having 进行再过滤。
```

```
例如，要 emp 表中统计公司的总人数：
mysql> select count(1) from emp;
+----------+
| count(1) |
+----------+
| 4 |
+----------+
1 row in set (0.00 sec)
在此基础上，要统计各个部门的人数：
mysql> select deptno,count(1) from emp group by deptno;
+--------+----------+
| deptno | count(1) |
+--------+----------+
| 1 | 2 |
| 2 | 1 |
| 4 | 1 |
+--------+----------+
3 rows in set (0.00 sec)
更细一些，既要统计各部门人数，又要统计总人数：
mysql> select deptno,count(1) from emp group by deptno with rollup;
+--------+----------+
| deptno | count(1) |
+--------+----------+
| 1 | 2 |
| 2 | 1 |
| 4 | 1 |
| NULL | 4 |
+--------+----------+
4 rows in set (0.00 sec)
统计人数大于 1 人的部门：
mysql> select deptno,count(1) from emp group by deptno having count(1)>1;
+--------+----------+
| deptno | count(1) |
+--------+----------+
| 1 | 2 |
+--------+----------+
1 row in set (0.00 sec)
最后统计公司所有员工的薪水总额、最高和最低薪水：
mysql> select * from emp;
+--------+------------+---------+--------+
| ename | hiredate | sal | deptno |
+--------+------------+---------+--------+
| zzx | 2000-01-01 | 100.00 | 1 |
| lisa | 2003-02-01 | 400.00 | 2 |
| bjguan | 2004-04-02 | 100.00 | 1 |
| dony | 2005-02-05 | 2000.00 | 4 |
+--------+------------+---------+--------+
4 rows in set (0.00 sec)
mysql> select sum(sal),max(sal),min(sal) from emp;
+----------+----------+----------+
| sum(sal) | max(sal) | min(sal) |
+----------+----------+----------+
| 2600.00 | 2000.00 | 100.00 |
+----------+----------+----------+
1 row in set (0.00 sec
```

（5）表连接。

当需要同时显示多个表中的字段时，就可以用表连接来实现这样的功能。

从大类上分，表连接分为内连接和外连接，它们之间的最主要区别是內连接仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录。我们最常用的是内连接

> select ename,deptname from emp,dept where emp.deptno=dept.deptno;

外连接有分为左连接和右连接，具体定义如下。
? 左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录
? 右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录

>select ename,deptname from emp left join dept on emp.deptno=dept.deptno;


（6）子查询。
某些情况下，当我们查询的时候，需要的条件是另外一个 select 语句的结果，这个时候，就
要用到子查询。用于子查询的关键字主要包括 in、not in、=、!=、exists、not exists 等。

> select * from emp where deptno in(select deptno from dept);

```
注意：子查询和表连接之间的转换主要应用在两个方面：
?  MySQL 4.1 以前的版本不支持子查询，需要用表连接来实现子查询的功能
?  表连接在很多情况下用于优化子查询
```

（7）记录联合。
我们经常会碰到这样的应用，将两个表的数据按照一定的查询条件查询出来后，将结果合并
到一起显示出来，这个时候，就需要用 union 和 union all 关键字来实现这样的功能，具体语
法如下：

SELECT * FROM t1
UNION|UNION ALL
SELECT * FROM t2
……
UNION|UNION ALL
SELECT * FROM tn;

UNION 和 UNION ALL 的主要区别是 UNION ALL 是把结果集直接合并在一起，而 **UNION 是将
UNION ALL 后的结果进行一次 DISTINCT，去除重复记录后的结果。**


*****

##### DCL 语句

DCL 语句主要是 DBA 用来管理系统中的对象权限时所使用，一般的开发人员很少使用。下面
通过一个例子来简单说明一下。

创建一个数据库用户 z1，具有对 sakila 数据库中所有表的 SELECT/INSERT 权限：

>mysql> grant select,insert on sakila.* to 'z1'@'localhost' identified by '123';

在数据库sakila的所有记录给zi用户，密码是123


由于权限变更，需要将 z1 的权限变更，收回 INSERT，只能对数据进行 SELECT 操作：

>revoke insert on sakila.* from 'z1'@'localhost';

 grant 和 revoke 分别授出和收回了用户 z1 的部分权限，达到了我们的目的。

#### 按照层次看帮助

如果不知道帮助能够提供些什么，可以用“？contents”命令来显示所有可供查询的的分类，
如下例所示：

mysql> ? contents

对于列出的分类，可以使用“? 类别名称”的方式针对用户感兴趣的内容做进一步的查看

#### 快速查阅帮助
在实际应用当中，如果需要快速查阅某项语法时，可以使用关键字进行快速查询。例如，想
知道 show 命令都能看些什么东西，可以用如下命令：
mysql> ? show

mysql> ? create table




# 第二章

在整数类型中，按照取值范围和存储方式不同，分为 tinyint、smallint、mediumint、int、
bigint 这 5 个类型

```
分别修改 id1 和 id2 的字段类型，加入 zerofill 参数：
mysql> alter table t1 modify id1 int zerofill;
Query OK, 1 row affected (0.04 sec)
Records: 1 Duplicates: 0 Warnings: 0
mysql> alter table t1 modify id2 int(5) zerofill;
Query OK, 1 row affected (0.03 sec)
Records: 1 Duplicates: 0 Warnings: 0
mysql> select * from t1;
+------------+-------+
| id1 | id2 |
+------------+-------+
| 0000000001 | 00001 |
+------------+-------+
1 row in set (0.00 sec)
``` 


所有的整数类型都有一个可选属性 UNSIGNED（无符号），如果需要在字段里面保存非
负数或者需要较大的上限值时，可以用此选项，它的取值范围是正常值的下限取 0，上限取
原值的 2 倍

，例如，tinyint 有符号范围是-128～+127，而无符号范围是 0～255。如果一个列
指定为 zerofill，则 MySQL 自动为该列添加 UNSIGNED 属性。
另外，整数类型还有一个属性：AUTO_INCREMENT。在需要产生唯一标识符或顺序值时，
可利用此属性，这个属性只用于整数类型。AUTO_INCREMENT 值一般从 1 开始，每行增加 1。


浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示，“(M,D)”表示该
值一共显示 M 位数字（整数位+小数位），其中 D 位位于小数点后面，M 和 D 又称为精度和
标度。例如 定义为 float(7,4)的一个列可以显示为-999.9999

 decimal 在不指定精度时，默认的整数位为 10，默认的小数位为 0。


浮点数如果不写精度和标度，则会按照实际精度值显示，如
果有精度和标度，则会自动将四舍五入后的结果插入，系统不会报错；定点数如果不写精度
和标度，则按照默认值 decimal(10,0)来进行操作，并且如果数据超越了精度和标度值，系统
则会报错。


对于 BIT（位）类型，用于存放位字段值，BIT(M)可以用来存放多位二进制数，M 范围从 1～
64，如果不写则默认为 1 位。对于位字段，直接使用 SELECT 命令将不会看到结果，可以用
bin()（显示为二进制格式）或者 hex()（显示为十六进制格式）函数进行读取。
下面的例子中，对测试表 t2 中的 bit 类型字段 id 做 insert 和 select 操作，这里重点观察一下
select 的结果：

```

mysql> desc t2;
+-------+--------+------+-----+---------+-------+
Linux公社 www.linuxidc.com
62
| Field | Type | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id | bit(1) | YES | | NULL | |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)
mysql> insert into t2 values(1);
Query OK, 1 row affected (0.00 sec)
mysql> select * from t2;
+------+
| id |
+------+
| |
+------+
1 row in set (0.00 sec)
可以发现，直接 select * 结果为 NULL。改用 bin()和 hex()函数再试试：
mysql> select bin(id),hex(id) from t2;
+---------+---------+
| bin(id) | hex(id) |
+---------+---------+
| 1 | 1 |
+---------+---------+
1 row in set (0.00 sec)
结果可以正常显示为二进制数字和十六进制数字。
```

##### 日期时间类型


|日期和时间类型| 字节 | 最小值|  最大值|
|----|----|----|----|
|DATE|  4 | 1000-01-01 | 9999-12-31
|DATETIME | 8 | 1000-01-01 00:00:00  |9999-12-31 23:59:59
|TIMESTAMP | 4 | 19700101080001 | 2038 年的某个时刻
|TIME  |3 | -838:59:59 | 838:59:59
|YEAR|  1 | 1901|  2155

*  如果要用来表示年月日，通常用 DATE 来表示。
*  如果要用来表示年月日时分秒，通常用 DATETIME 表示。
*  如果只用来表示时分秒，通常用 TIME 来表示。
*  如果需要经常插入或者更新日期为当前系统时间，则通常使用 TIMESTAMP 来表示。
TIMESTAMP 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串，显示宽度固定
为 19 个字符。如果想要获得数字值，应在 TIMESTAMP 列添加+0。
*  如果只是表示年份，可以用 YEAR 来表示，它比 DATE 占用更少的空间。YEAR 有 2 位或
4 位格式的年。默认是 4 位格式。在 4 位格式中，允许的值是 1901～2155 和 0000。在
2 位格式中，允许的值是 70～69，表示从 1970～2069 年。MySQL 以 YYYY 格式显示 YEAR
值。

timestamp 

创建测试表t，字段id1为TIMESTAMP类型：

```
mysql> create table t (id1 timestamp);
Query OK, 0 rows affected (0.03 sec)
mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id2 | timestamp | YES | | CURRENT_TIMESTAMP | |
+-------+-----------+------+-----+-------------------+-------+
1 row in set (0.00 sec)
```


可以发现，系统给 tm 自动创建了默认值 CURRENT_TIMESTAMP（系统日期）。插入一个 NULL
值试试：

```
mysql> insert into t values(null);
Query OK, 1 row affected (0.00 sec)
mysql> select * from t;
+---------------------+
| t |
+---------------------+
| 2007-07-04 16:37:24 |
+---------------------+
```


MySQL只给表中的第一个TIMESTAMP字段设置
默认值为系统日期，如果有第二个TIMESTAMP类型，则默认值设置为0值，测试如下：

```
mysql> alter table t add id2 timestamp;
Query OK, 0 rows affected (0.03 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql> show create table t \G;
*************************** 1. row ***************************
Table: t
Create Table: CREATE TABLE `t` (
`id1` timestamp NOT NULL default CURRENT_TIMESTAMP,
`id2` timestamp NOT NULL default '0000-00-00 00:00:00'
) ENGINE=MyISAM DEFAULT CHARSET=gbk
1 row in set (0.00 sec))
```


查看当前时区：
> show variables like 'time_zone';

修改时区为东九区，再次查看表中日期：
> set time_zone='+9:00';


##### CHAR 和 VARCHAR 类型

CHAR 和 VARCHAR 很类似，都用来保存 MySQL 中较短的字符串。二者的主要区别在于存储
方式的不同：CHAR 列的长度固定为创建表时声明的长度，长度可以为从 0～255 的任何值；
而 VARCHAR 列中的值为可变长字符串，长度可以指定为 0～255 （5.0.3以前）或者 65535 （5.0.3
以后）之间的值。在检索的时候，CHAR 列删除了尾部的空格，而 VARCHAR 则保留这些空格



```
（1）创建测试表 vc，并定义两个字段 v VARCHAR(4)和 c CHAR(4)：

mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.16 sec)

（2）v 和 c 列中同时插入字符串“ab ”：

mysql> INSERT INTO vc VALUES ('ab ', 'ab ');
Query OK, 1 row affected (0.05 sec)

（3）显示查询结果：
mysql> select length(v),length(c) from vc;
+-----------+-----------+
Linux公社 www.linuxidc.com
71
| length(v) | length(c) |
+-----------+-----------+
| 4 | 2 |
+-----------+-----------+
1 row in set (0.01 sec)

可以发现，c 字段的 length 只有 2。给两个字段分别追加一个“+”字符看得更清楚：
mysql> SELECT CONCAT(v, '+'), CONCAT(c, '+') FROM vc;
+----------------+----------------+
| CONCAT(v, '+') | CONCAT(c, '+') |
+----------------+----------------+
| ab + | ab+ |
+----------------+----------------+
1 row in set (0.00 sec)
显然，CHAR 列最后的空格在做操作时都已经被删除，而 VARCHAR 依然保留空格。
```


#### 算术运算符

比较运算符

MySQL 支持的比较运算符

|运算符|作用|
|-----|-----|
|= | 等于|
|<>或!=  |不等于|
|<=>  |NULL 安全的等于(NULL-safe)|
|< | 小于|
|<= | 小于等于|
|> | 大于|
|>= | 大于等于|
|BETWEEN  |存在与指定范围|
|IN  |存在于指定集合|
|IS NULL | 为 NULL|
|IS NOT NULL | 不为 NULL|
|LIKE | 通配符匹配|
|REGEXP 或 RLIKE | 正则表达式匹配|

```
mysql> select 1 in (1,2,3) , 't' in ('t','a','b','l','e'),0 in (1,2);
+--------------+------------------------------+------------+
| 1 in (1,2,3) | 't' in ('t','a','b','l','e') | 0 in (1,2) |
+--------------+------------------------------+------------+
| 1 | 1 | 0 |
+--------------+-------------

mysql> select 'abcdef' regexp 'ab' ,'abcdefg' regexp 'k';
+----------------------+----------------------+
| 'abcdef' regexp 'ab' | 'abcdefg' regexp 'k' |
+----------------------+----------------------+
| 1 | 0 |
+----------------------+----------------------+
1 row in set (0.00 sec)	
```

### 逻辑运算符

MySQL 中的逻辑运算符

|运算符 | 作用|
|----|----|
|NOT 或！|  逻辑非|
|AND 或&&  |逻辑与|
|OR 或两个竖杠 |逻辑或|
|XOR | 逻辑异或|


```
“XOR”表示逻辑异或。当任意一个操作数为 NULL 时，返回值为 NULL。对于非 NULL 的
操作数，如果两个的逻辑真假值相异，则返回结果 1；否则返回 0。如下例所示：


mysql> select 1 xor 1 ,0 xor 0,1 xor 0,0 xor 1,null xor 1;
+---------+---------+---------+---------+------------+
| 1 xor 1 | 0 xor 0 | 1 xor 0 | 0 xor 1 | null xor 1 |
+---------+---------+---------+---------+------------+
| 0 | 0 | 1 | 1 | NULL |
+---------+---------+---------+---------+------------+
1 row in set (0.00 sec)
```


### 位运算

位运算符
位运算是将给定的操作数转化为二进制后，对各个操作数每一位都进行指定的逻辑运算，
得到的二进制结果转换为十进制数后就是位运算的结果。MySQL 5.0 支持 6 种位运算符，

 MySQL 支持的位运算符

|运算符 | 作用|
|---|---|
|& | 位与（位 AND）|
|竖杠 | 位或 （位 OR ）|
|^|  位异或（位 XOR）|
|~ | 位取反|
|>>| 位右移|
|<< |位左移|


#### 常用函数

![常用函数](https://i.loli.net/2017/09/23/59c5d354bc41b.png)


#### 数值函数
![数值函数](https://i.loli.net/2017/09/23/59c5eed50bf61.png)

![日期函数](https://i.loli.net/2017/09/23/59c5ef8970d3d.png)

#### 流程函数

![流程函数](https://i.loli.net/2017/09/23/59c5f36810b53.png)


```
IF(value,t,f)函数：我们认为月薪在 2000 元以上的职员属于高薪，用“high”表示；而
2000 元以下的职员属于低薪，用“low”表示。


mysql> select if(salary>2000,'high','low') from salary;
+------------------------------+
| if(salary>2000,'high','low') |
+------------------------------+
| low |
| low |
| high |
| high |
| high |
+------------------------------+
5 rows in set (0.01 sec)
```

CASE WHEN [value1] THEN[result1]…ELSE[default]END 函 数 ：

 我 们 也 可 以 用 case
when…then 函数实现上面例子中高薪低薪的问题。
mysql
> select case when salary<=2000 then 'low' else 'high' end from salary;


![其他函数](https://i.loli.net/2017/09/23/59c5f4e1a11d9.png)

>select DATABASE();

>select USER();


数据库详情
> show table status;


#### 存储引擎

MySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、
NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安
全表，其他存储引擎都是非事务安全表。


查看当前的默认存储引擎，
可以使用以下命令：

mysql> show variables like 'table_type';

可以通过下面两种方法查询当前数据库支持的存储引擎，第一种方法为：

mysql> SHOW ENGINES \G

或者采用第二种方法：

mysql> SHOW VARIABLES LIKE 'have%';


在创建新表的时候，可以通过增加 ENGINE 关键字设置新建表的存储引擎，例如，在下
面的例子中，表 ai 就是 MyISAM 存储引擎的，而 country 表就是 InnoDB 存储引擎的：

```
CREATE TABLE ai (
i bigint(20) NOT NULL AUTO_INCREMENT,
PRIMARY KEY (i)
) ENGINE=MyISAM DEFAULT CHARSET=gbk;

CREATE TABLE country (
country_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
country VARCHAR(50) NOT NULL,
last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (country_id)
)ENGINE=InnoDB DEFAULT CHARSET=gbk;
```


如何将表 ai 从 MyISAM 存储引擎修改成 InnoDB 存储引擎：
> alter table ai engine = innodb;


#### 各种存储引擎的特性:

![存储引擎](https://i.loli.net/2017/09/23/59c5fad5a550f.png)

***
### MyISAM

MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访
问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用
这个引擎来创建表。
***
### InnoDB 


#####外键约束

InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM
的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

MySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的
索引，子表在创建外键的时候也会自动创建对应的索引。

对于 InnoDB 类型的表，外键的信息通过使用 show create table 或者 show table status 命
令都可以显示。


###MEMORY
MEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个
磁盘文件，格式是.frm。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，
并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。

```
mysql> CREATE TABLE tab_memory ENGINE=MEMORY
-> SELECT city_id,city,country_id
-> FROM city GROUP BY city_id;
Query OK, 600 rows affected (0.06 sec)
Records: 600 Duplicates: 0 Warnings: 0
mysql> select count(*) from tab_memory;
+----------+
| count(*) |
+----------+
| 600 |
+----------+
1 row in set (0.00 sec)

mysql> show table status like 'tab_memory' \G

*************************** 1. row ***************************
Name: tab_memory
Engine: MEMORY
Version: 10
Row_format: Fixed
Rows: 600
Avg_row_length: 155
Data_length: 127040
Max_data_length: 16252835
Index_length: 0
Data_free: 0
Auto_increment: NULL
Create_time: NULL
Update_time: NULL
Check_time: NULL
Collation: gbk_chinese_ci
Checksum: NULL
Create_options:

Comment:
1 row in set (0.00 sec)
```

给 MEMORY 表创建索引的时候，可以指定使用 HASH 索引还是 BTREE 索引：

```
mysql> create index mem_hash USING HASH on tab_memory (city_id) ;
Query OK, 600 rows affected (0.04 sec)
Records: 600 Duplicates: 0 Warnings: 0

mysql> SHOW INDEX FROM tab_memory \G
*************************** 1. row ***************************
Table: tab_memory
Non_unique: 1
Key_name: mem_hash
Seq_in_index: 1
Column_name: city_id
Collation: NULL
Cardinality: 300
Sub_part: NULL
Packed: NULL
Null:
Index_type: HASH
Comment:
1 row in set (0.01 sec)
mysql> drop index mem_hash on tab_memory;
Query OK, 600 rows affected (0.04 sec)
Records: 600 Duplicates: 0 Warnings: 0
mysql> create index mem_hash USING BTREE on tab_memory (city_id) ;
Query OK, 600 rows affected (0.03 sec)
Records: 600 Duplicates: 0 Warnings: 0

mysql> SHOW INDEX FROM tab_memory \G
*************************** 1. row ***************************
Table: tab_memory
Non_unique: 1
Key_name: mem_hash
Seq_in_index: 1
Column_name: city_id
Collation: A
Cardinality: NULL
Sub_part: NULL
Packed: NULL
Null:
Index_type: BTREE
Comment:
1 row in set (0.00 sec)
```